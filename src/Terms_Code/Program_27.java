package Terms_Code;

// Абстрактные классы и методы.
/**
 * Кроме обычных классов в Java есть абстрактные классы. Абстрактный класс похож
 * на обычный класс.
 * 
 * В абстрактном классе также можно определить поля и методы, но в то же время
 * нельзя !!! создать объект или экземпляр абстрактного класса (в Program)!!!
 * 
 * Абстрактные классы призваны !!! предоставлять базовый функционал для
 * классов-наследников!!! А производные классы (наследники, подклассы) уже
 * реализуют этот функционал.
 * 
 * При определении абстрактных классов используется ключевое слово abstract:
 * 
 * public abstract class Human{
 * private String name;
 * 
 * public String getName() {
 * return name;
 * }
 * }
 * 
 * !!! Но главное отличие состоит в том, что мы не можем использовать
 * конструктор абстрактного класса для создания его объекта.
 * Например, следующим образом:
 * 
 * Human h = new Human(); - нельзя использовать конструктор в Program!!!
 * 
 * Кроме обычных методов абстрактный класс может содержать абстрактные методы.
 * Такие методы определяются с помощью ключевого слова abstract и не имеют
 * никакой реализации:
 * 
 * public abstract void display(); - нет реализации!!!
 * 
 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 * 
 * Производный класс обязан !!! переопределить и реализовать все абстрактные
 * методы, которые имеются в базовом абстрактном классе!!!
 * 
 * Также следует учитывать, что если !класс имеет хотя бы один !абстрактный
 * метод, то !данный класс !должен быть определен как !абстрактный.
 * 
 * Зачем нужны абстрактные классы?
 * 
 * Допустим, мы делаем программу для обслуживания банковских операций и
 * определяем в ней три класса:
 * 
 * класс Person27, который описывает человека,
 * класс Employee27, который описывает банковского служащего, и
 * класс Client27, который представляет клиента банка.
 * 
 * Очевидно, что классы Employee27 и Client27 будут производными (подклассами,
 * наследниками) от класса Person27, так как оба класса имеют некоторые общие
 * поля и методы!
 * И так как все !объекты будут представлять !либо сотрудника, !либо клиента
 * банка, то напрямую мы !от класса Person27 создавать !объекты не будем.
 * !Поэтому имеет смысл сделать его (Person27) абстрактным:
 * 
 */

public class Program_27 {

    public static void main(String[] args) {

        Employee27 sam = new Employee27("Sam", "Leman Brothers");
        sam.display(); // Employee Name: Sam Bank: Leman Brothers
        Client27 bob = new Client27("Bob", "Leman Brothers");
        bob.display(); // Client Name: Bob Bank: Leman Brothers
    }
}

abstract class Person27 { // абстрактный базовый класс

    private String name;

    public String getName() {
        return name;
    }

    protected Person27(String name) { // описали абстрактного класса

        this.name = name;
    }

    public abstract void display(); // абстрактный метод без реализации,
                                    // который обязан переопределиться в произ-х классах
}

class Employee27 extends Person27 { // подкласс (сотрудник банка), наследник базового класса

    private String bank; // определили поле bank

    public Employee27(String name, String company) { // реализовали экземпляр класса

        super(name);
        this.bank = company; // присваиваться компания, где работает сотрудник банка, в этом же классе
    }

    public void display() { // переопределили (обязаны) абстрактный метод базового класса

        System.out.printf("Employee Name: %s \t Bank: %s \n", super.getName(), bank);
        // выводим имя сотрудник банка из этого класса (Employee27) через функционал
        // базового класса (Person27) и название банка, где работает сотрудник через
        // этот класс Employee27
    }
}

class Client27 extends Person27 { // подкласс (клиент банка), наследник базового класса
    private String bank;

    public Client27(String name, String company) {

        super(name); // вызываем конструктор базового класса
        this.bank = company; // присваиваеи значение параметра из экземпляра класса (Client27) в поле
                             // (переменную) подкласса (Client27)
    }

    public void display() { // переопределяем (обязаны) абстрактный метод базового класса (Person27)

        System.out.printf("Client Name: %s \t Bank: %s \n", super.getName(), bank);
        // печатаем имя, обащаемся к фунционалу базового класса (Person27) и банк, куда
        // пришёл клиент через этот же произ-й класс (Client27)
    }
}
